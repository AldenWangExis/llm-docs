import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as t,d as s,r,o as p}from"./app-BB4DuYtW.js";const i={};function g(l,n){const e=r("Mermaid");return p(),a("div",null,[n[0]||(n[0]=t('<h1 id="agent-自主执行代理" tabindex="-1"><a class="header-anchor" href="#agent-自主执行代理"><span>Agent：自主执行代理</span></a></h1><h2 id="从被动响应到主动执行" tabindex="-1"><a class="header-anchor" href="#从被动响应到主动执行"><span>从被动响应到主动执行</span></a></h2><p>LLM擅长理解和生成文本，RAG为其提供外部知识，但它们都局限于&quot;被动响应&quot;模式：接收输入，返回输出，任务结束。</p><p><strong>Agent（智能体）</strong> 打破了这一限制。它将LLM从&quot;文本处理器&quot;升级为&quot;任务执行器&quot;，赋予其三大能力：</p><ol><li><strong>规划（Planning）</strong>：将复杂目标拆解为可执行的子任务</li><li><strong>工具调用（Tool Use）</strong>：调用外部API、数据库、终端命令</li><li><strong>闭环反馈（Closed-loop Feedback）</strong>：根据执行结果调整策略，必要时重试或回溯</li></ol><p>这种能力转变可类比为：</p><table><thead><tr><th>传统LLM</th><th>AI Agent</th></tr></thead><tbody><tr><td>问答机器人</td><td>全栈工程师</td></tr><tr><td><code>grep &quot;error&quot; log.txt</code></td><td>自动定位错误、搜索解决方案、生成修复补丁</td></tr><tr><td>生成SQL查询</td><td>执行查询、分析结果、生成可视化报告</td></tr></tbody></table><h2 id="核心架构-react循环" tabindex="-1"><a class="header-anchor" href="#核心架构-react循环"><span>核心架构：ReAct循环</span></a></h2><p>目前最主流的Agent设计模式是 <strong>ReAct（Reasoning and Acting）</strong>。它模仿人类解决问题的思维过程，在&quot;思考&quot;与&quot;行动&quot;之间迭代。</p>',9)),s(e,{code:"eJxLL0osyFDwCeJSAILgksSikuhnfUufTdn2ZPfup10LYxV0de0UQjIy87KjQzLyS9MzSqwUnna0PZs34eneyU87e593bXvW0BgL1g5WBtbgmFwSDcSZ+XlWCi8bOp91r3y6fenT1u1Pd2571rn8xcIeiAagErBy/6TiaCBOLSpLhOh50bf9af80iNLnuyc/mzcHogGoCKzBJTU5sxioshriymcz1j+dsOzpup5nHRPsa8EqYSpAymuAkjUQ12HKAfXWKLjmpUS/2D/l6ex5z+Y0PN/d8XztlGcLOyB2goniksqcVKgH0zJzcqyUUw3TTNPSkCRBnoFIpaWlGqYaIkmBnA3XBZTkAgAdDpv/"}),n[1]||(n[1]=t('<h3 id="react的执行流程" tabindex="-1"><a class="header-anchor" href="#react的执行流程"><span>ReAct的执行流程</span></a></h3><p>以&quot;分析上个月服务器日志异常&quot;为例，展示四轮迭代：</p><ol><li><strong>思考</strong> → 需要日志数据 → <strong>行动</strong> → 调用日志查询工具 → <strong>观察</strong> → 获得文件路径</li><li><strong>思考</strong> → 需要统计错误 → <strong>行动</strong> → 调用错误分析工具 → <strong>观察</strong> → 发现ConnectionTimeout高频</li><li><strong>思考</strong> → 需要解决方案 → <strong>行动</strong> → 调用搜索工具 → <strong>观察</strong> → 获得相关文档</li><li><strong>思考</strong> → 信息充足 → <strong>行动</strong> → 生成报告 → <strong>结束</strong></li></ol><p>核心机制：每轮的Observation会追加到上下文中，影响下一轮的Thought。这种闭环反馈使Agent能够根据执行结果动态调整策略。</p><h3 id="工程实现的核心机制" tabindex="-1"><a class="header-anchor" href="#工程实现的核心机制"><span>工程实现的核心机制</span></a></h3><p>ReAct并非模型的内置能力，而是通过三个工程组件实现：</p><p><strong>1. 工具定义（Tool Schema）</strong></p><p>每个工具包含名称、描述、参数定义。这些信息会注入到Prompt中，让模型&quot;知道&quot;可以调用哪些能力。</p><p>设计要点：描述必须精确，模糊的描述会导致模型误用工具。参数定义需要包含类型和约束，便于后续验证。</p><p><strong>2. Prompt模板（ReAct Template）</strong></p><p>系统指令定义了严格的输出格式：<code>Thought → Action → Action Input</code>。这种结构化约束是ReAct工作的前提。</p><p>关键权衡：格式越严格，解析越可靠，但也限制了模型的灵活性。生产环境通常选择严格格式。</p><p><strong>3. 执行循环（Agent Loop）</strong></p><p>宿主程序循环执行四步：LLM推理 → 解析Action → 执行工具 → 追加Observation。循环终止条件是模型输出<code>finish</code>或达到最大步数。</p><div class="hint-container warning"><p class="hint-container-title">循环终止条件</p><p>必须设置最大迭代次数（如20轮），防止Agent陷入死循环。生产环境中，Agent的规划能力仍不完美，可能重复调用相同工具或选择错误的策略。</p></div><h2 id="工具调用的两种范式" tabindex="-1"><a class="header-anchor" href="#工具调用的两种范式"><span>工具调用的两种范式</span></a></h2><h3 id="_1-function-calling-函数调用" tabindex="-1"><a class="header-anchor" href="#_1-function-calling-函数调用"><span>1. Function Calling（函数调用）</span></a></h3><p>由模型厂商（如OpenAI、Anthropic）通过微调实现。模型输出结构化的JSON，直接映射到函数参数。</p><p>工作机制：模型在训练时学习了&quot;何时调用工具&quot;和&quot;如何构造参数&quot;。输出格式固定为<code>{&quot;name&quot;: &quot;tool_name&quot;, &quot;arguments&quot;: {...}}</code>，无需复杂的文本解析。</p><p><strong>优势</strong>：输出稳定，格式规范，响应速度快<br><strong>限制</strong>：只支持特定模型，灵活性较低，工具定义必须符合厂商的Schema规范</p><h3 id="_2-react-agents-推理代理" tabindex="-1"><a class="header-anchor" href="#_2-react-agents-推理代理"><span>2. ReAct Agents（推理代理）</span></a></h3><p>通过Prompt Engineering实现，适用于所有模型。Agent自己描述需要调用的工具，由宿主程序解析执行。</p><p><strong>优势</strong>：灵活度高，可处理复杂的多步推理<br><strong>限制</strong>：输出格式可能不稳定，需要健壮的解析逻辑</p><h2 id="agent的核心组件" tabindex="-1"><a class="header-anchor" href="#agent的核心组件"><span>Agent的核心组件</span></a></h2><p>一个完整的Agent系统包含以下模块：</p>',25)),s(e,{code:"eJxLL0osyFAIceFSAAKnosTMvGgfH99nfSueT2h7umfqs8l9sQq6unYKATmJeXmZeenRL5a3PO2Y9GzFwqdzp8cidIEV+abm5hdVRr9Yt+Hp/rbnm3c/3z0fXUlIfn5OcfTT7Uuftm5/ObsNIg0mIJrBioIz8otKQlKLcqOfz1/7bM58iIFWCk92dD3Z0f1sWvvzVdOf9i+GaEbS55Oflw7W9nLqfiRtTydMfNne/2zqhme9657umoxkJ9g1YK2OAZ7RQPysbyncYISkc35KavST3YufL2h81rn8xcIedAXBqYlFyRnRzybMeb5lETTY0JQEOboDfbP0xfq2Z4sbgKqQXFFcUpmTCg2jtMycHCvltLRUw1RDJEmoJyGyqYYgeSRZiC0wSZA0FwBFB8F4"}),n[2]||(n[2]=t('<h3 id="规划模块-planning" tabindex="-1"><a class="header-anchor" href="#规划模块-planning"><span>规划模块（Planning）</span></a></h3><p>将高层目标拆解为有向无环图（DAG）。</p><p><strong>示例任务</strong>：&quot;生成本季度销售分析报告&quot;</p><p>拆解为：</p><ol><li>从数据库查询销售数据</li><li>清洗和聚合数据</li><li>生成可视化图表</li><li>编写分析文本</li><li>组装为PDF报告</li></ol><p><strong>实现方式</strong>：</p><ul><li><strong>任务分解（Task Decomposition）</strong>：让LLM输出步骤列表</li><li><strong>依赖分析</strong>：识别步骤间的依赖关系（如步骤2必须在步骤1之后）</li></ul><h3 id="记忆系统-memory" tabindex="-1"><a class="header-anchor" href="#记忆系统-memory"><span>记忆系统（Memory）</span></a></h3><p><strong>短期记忆</strong>：存储在上下文窗口中的对话历史。随着交互增多，早期消息会被截断。这类似于CPU的寄存器，容量有限但访问速度快。</p><p><strong>长期记忆</strong>：将历史交互存入向量数据库。Agent可以检索过去的经验，学习错误教训。这类似于硬盘，容量大但需要主动检索。</p><p>架构权衡：短期记忆自动可用，但会占用上下文窗口；长期记忆需要显式检索，增加延迟但可以存储无限历史。生产系统通常采用混合策略：关键信息保留在短期记忆，详细历史存入长期记忆。</p><h3 id="工具集-tools" tabindex="-1"><a class="header-anchor" href="#工具集-tools"><span>工具集（Tools）</span></a></h3><p>Agent的&quot;手脚&quot;，实现与外部世界的交互。</p><p><strong>典型工具类型</strong>：</p><table><thead><tr><th>工具类型</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td>数据查询</td><td>执行SQL、调用API</td><td><code>query_database</code>, <code>fetch_api</code></td></tr><tr><td>代码执行</td><td>运行Python/Bash脚本</td><td><code>execute_python</code>, <code>run_shell</code></td></tr><tr><td>知识检索</td><td>调用RAG系统</td><td><code>search_docs</code></td></tr><tr><td>外部服务</td><td>发送邮件、通知</td><td><code>send_email</code>, <code>post_slack</code></td></tr></tbody></table><h2 id="高级模式-agentic-rag" tabindex="-1"><a class="header-anchor" href="#高级模式-agentic-rag"><span>高级模式：Agentic RAG</span></a></h2><p>将RAG系统作为Agent的一个工具，实现主动的知识检索。</p><p><strong>传统RAG</strong>：每次都检索，无论是否需要<br><strong>Agentic RAG</strong>：Agent自主判断何时检索、检索什么、是否需要二次检索</p><p>决策逻辑示例：</p><ol><li><strong>分析问题复杂度</strong>：简单事实问题直接回答，复杂问题启动检索</li><li><strong>选择检索策略</strong>：根据问题类型决定过滤条件（如时间范围、文档类别）</li><li><strong>评估检索质量</strong>：如果相关度低，重写查询词并重新检索</li></ol><p>核心优势：将&quot;是否检索&quot;从固定流程变为动态决策，避免不必要的检索开销，同时提高检索精度。这种模式极大提高了系统的效率和准确性。</p><h2 id="工具集成的统一标准-mcp" tabindex="-1"><a class="header-anchor" href="#工具集成的统一标准-mcp"><span>工具集成的统一标准：MCP</span></a></h2><p>随着Agent生态的爆发，工具集成陷入碎片化困境。每个Agent框架（LangChain、CrewAI、AutoGen）都需要为每个工具（GitHub、Slack、Notion）编写专用的适配代码。</p><p><strong>模型上下文协议（Model Context Protocol, MCP）</strong> 应运而生，目标是成为AI领域的&quot;USB-C接口&quot;。</p><h3 id="mcp架构" tabindex="-1"><a class="header-anchor" href="#mcp架构"><span>MCP架构</span></a></h3>',25)),s(e,{code:"eJxLL0osyFDwCeJSAALH9NS8kmhHTwgjVkFX107BOScTJOjrHPB03aJnHdufr14fC1YMkQCrCSjKL8lPzs8Bq+rtf7Fu3dONTVYKXsH+frpBAc4KRnoGED0whWBdwalFZalFhiBNz+b0Pu1a+HTmCisF98wSj9IknMqN0JQH5BeXpBelBgf64NRijKbFLTMntbiyuCQ1F6IFTBSXVOakInSnZebkWCmnpaUaphoiyUP9DJFNNQTJcwEA4ABzjg=="}),n[3]||(n[3]=t(`<p><strong>核心角色</strong>：</p><ol><li><strong>MCP服务器</strong>：封装具体能力的微服务（如数据库连接、文件系统访问）</li><li><strong>MCP客户端</strong>：运行Agent的宿主程序，负责与服务器通信</li><li><strong>MCP协议</strong>：基于JSON-RPC 2.0的标准指令集</li></ol><h3 id="mcp的工程价值" tabindex="-1"><a class="header-anchor" href="#mcp的工程价值"><span>MCP的工程价值</span></a></h3><p><strong>统一接口</strong>：所有工具遵循相同的协议，Agent无需为每个工具编写适配代码</p><p>架构对比：</p><ul><li><strong>传统方式</strong>：N个Agent × M个工具 = N×M个适配器（碎片化）</li><li><strong>MCP方式</strong>：N个Agent + M个工具 = N+M个实现（标准化）</li></ul><p>这种架构降低了集成复杂度，新工具只需实现MCP协议即可被所有Agent使用。</p><p><strong>渐进式披露</strong>：传统方式需要预先将所有工具定义塞入上下文，浪费Token。MCP支持按需加载。</p><p>工作机制：Agent初始只看到工具列表，需要时才获取详细Schema。这种延迟加载策略节省了上下文空间，使Agent能够访问数百个工具而不超出窗口限制。</p><p><strong>代码执行能力</strong>：MCP原生支持在沙箱中执行Agent生成的代码</p><p>设计价值：避免将海量原始数据塞入上下文。Agent生成数据处理脚本，MCP在隔离环境中执行，只返回处理后的结果（如统计摘要、可视化图表）。这种模式将计算从LLM转移到本地环境，大幅降低Token成本。</p><h2 id="生产化挑战与对策" tabindex="-1"><a class="header-anchor" href="#生产化挑战与对策"><span>生产化挑战与对策</span></a></h2><p>将Agent部署到生产环境，需要解决三大核心问题：</p><h3 id="_1-可靠性问题" tabindex="-1"><a class="header-anchor" href="#_1-可靠性问题"><span>1. 可靠性问题</span></a></h3><p><strong>挑战</strong>：Agent的推理路径不确定，可能调用错误的工具、传递错误的参数、陷入死循环</p><p><strong>对策</strong>：</p><ul><li><p><strong>Schema验证</strong>：所有工具调用必须通过JSON Schema验证。这是防御性编程的第一道防线，拒绝格式错误的参数。</p></li><li><p><strong>最大步数限制</strong>：强制终止超过N轮的循环（通常20轮）。这防止Agent在无法完成任务时无限消耗资源。</p></li><li><p><strong>确定性参数</strong>：生产环境使用<code>temperature=0</code>，降低输出随机性。这牺牲了创造力，但换来了行为的可预测性。</p></li></ul><h3 id="_2-安全性问题" tabindex="-1"><a class="header-anchor" href="#_2-安全性问题"><span>2. 安全性问题</span></a></h3><p><strong>挑战</strong>：Agent具备执行权限，可能被Prompt注入攻击利用</p><p><strong>威胁场景</strong>：用户输入包含&quot;System Override&quot;等指令，试图覆盖系统Prompt，诱导Agent执行危险操作（如<code>DROP TABLE</code>）。</p><p><strong>对策</strong>：</p><ul><li><p><strong>权限最小化</strong>：每个工具绑定专用的受限IAM身份。例如查询工具只有<code>SELECT</code>权限，且仅限特定表。这确保即使Agent被劫持，也无法执行破坏性操作。</p></li><li><p><strong>沙箱执行</strong>：代码在隔离容器中运行，禁用网络访问，设置超时限制。这将潜在破坏限制在沙箱内，保护宿主系统。</p></li><li><p><strong>输入过滤</strong>：检测并拒绝可疑的Prompt注入模式（如&quot;Ignore previous instructions&quot;）。这是启发式防御，无法100%防御，但可以拦截大部分常见攻击。</p></li></ul><h3 id="_3-可观测性问题" tabindex="-1"><a class="header-anchor" href="#_3-可观测性问题"><span>3. 可观测性问题</span></a></h3><p><strong>挑战</strong>：Agent的推理过程是黑盒，难以定位为什么在某一步&quot;走歪&quot;了</p><p><strong>对策</strong>：</p><ul><li><p><strong>结构化日志</strong>：记录每一轮的Thought、Action、Observation，以及Token消耗和延迟。这些数据是事后分析的基础。</p></li><li><p><strong>Trace可视化</strong>：生成执行流程图，展示每步的耗时和状态。这使得复杂的多步任务可以一目了然地审查。</p></li><li><p><strong>成本追踪</strong>：监控Token消耗和API费用。Agent的多轮迭代可能导致成本激增，实时监控可以触发预算告警或自动降级。</p></li></ul><p>设计原则：可观测性不是事后补救，而是架构的一部分。生产级Agent必须在设计阶段就内置日志、追踪和监控能力。</p><h2 id="架构定位" tabindex="-1"><a class="header-anchor" href="#架构定位"><span>架构定位</span></a></h2><p>Agent是AI工程栈的&quot;操作系统层&quot;，负责任务编排和执行控制。它整合其他组件：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>用户目标 </span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Agent规划</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>┌─────────┬─────────┬─────────┐</span></span>
<span class="line"><span>│ 调用LLM │ 调用RAG │ 调用工具 │</span></span>
<span class="line"><span>└─────────┴─────────┴─────────┘</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>执行结果 → 反馈到Agent → 继续规划</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>最终答案</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>与LLM的关系</strong>：Agent使用LLM作为推理引擎，但不局限于单次调用<br><strong>与RAG的关系</strong>：Agent将RAG作为一个可选的知识检索工具<br><strong>与MCP的关系</strong>：Agent通过MCP协议连接到标准化的工具生态</p><p>将Agent视为一个自动化的DevOps工程师：它理解任务目标，制定执行计划，调用各种工具（LLM、数据库、API），监控执行结果，必要时调整策略。整个过程遵循闭环控制逻辑，直到任务完成。</p>`,32))])}const h=o(i,[["render",g]]),u=JSON.parse('{"path":"/guide/01-concepts/agent.html","title":"Agent：自主执行代理","lang":"zh-CN","frontmatter":{"title":"Agent：自主执行代理","order":3,"description":"Agent：自主执行代理 从被动响应到主动执行 LLM擅长理解和生成文本，RAG为其提供外部知识，但它们都局限于\\"被动响应\\"模式：接收输入，返回输出，任务结束。 Agent（智能体） 打破了这一限制。它将LLM从\\"文本处理器\\"升级为\\"任务执行器\\"，赋予其三大能力： 规划（Planning）：将复杂目标拆解为可执行的子任务 工具调用（Tool Use）：...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Agent：自主执行代理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-08T11:53:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Alden\\",\\"url\\":\\"https://aldenwangexis.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/llm-docs/guide/01-concepts/agent.html"}],["meta",{"property":"og:site_name","content":"LLM工程实践教程"}],["meta",{"property":"og:title","content":"Agent：自主执行代理"}],["meta",{"property":"og:description","content":"Agent：自主执行代理 从被动响应到主动执行 LLM擅长理解和生成文本，RAG为其提供外部知识，但它们都局限于\\"被动响应\\"模式：接收输入，返回输出，任务结束。 Agent（智能体） 打破了这一限制。它将LLM从\\"文本处理器\\"升级为\\"任务执行器\\"，赋予其三大能力： 规划（Planning）：将复杂目标拆解为可执行的子任务 工具调用（Tool Use）：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-08T11:53:16.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-08T11:53:16.000Z"}]]},"git":{"createdTime":1767872442000,"updatedTime":1767873196000,"contributors":[{"name":"AldenWangExis","username":"AldenWangExis","email":"wangzihao286@126.com","commits":3,"url":"https://github.com/AldenWangExis"}]},"readingTime":{"minutes":10.03,"words":3010},"filePathRelative":"guide/01-concepts/agent.md","autoDesc":true}');export{h as comp,u as data};
